# helm 공부하기

도커와 쿠버네티스는 컨테이너 인프라를 구축하는 서비스였고 과정을 정리하면 다음과 같다.  

1. 깃헙이나 로컬에서 소스 코드를 다운하고 docker image로 빌드
2. docker hub 등 registry로 이미지 push
3. 레지스트리에 있는 이미지를 이용해 쿠버네티스의 파드 등 오브젝트로 생성
4. 외부에서 접근할 수 있는 서비스 형태로 배포

위 과정을 파이프라인(pipeline)이라 하고 실습에서는 이를 모두 수작업으로 진행했다. 그래서 코드에 수정 사항이 생기면 다시 이미지를 빌드하고 레지스트리에 올리고 기존 파드를 지운 후 다시 생성했다. 이는 상당히 번거로운 과정이므로 이를 자동화하는 CI/CD(Continuous Integration/Continuous Deployment) 툴이 등장했다.  

CI/CD 툴인 젠킨스를.... 또 툴이 있어 또? 캬

## 배포 간편화 도구: helm
helm은 쿠버네티스 패키지 매니저로, 개발한 패키지에 대한 스펙을 **차트** 형식으로 작성해 아티팩트허브(원격 저장소)에 올리면 쿠버네티스 오브젝트로 간단하게 설치할 수 있다.  

차트는 야믈 파일의 불편함을 처리한 스펙 명시 형태다. 하나의 프로그램 개발을 위해 여러 쿠버네티스 오브젝트가 필요하면 각 목적에 맞는 디렉토리에 야믈 파일을 하나씩 작성하거나 하나의 야믈 파일에 "---"을 기준으로 분리해서 작성했다. 이 방식은 생성해야 할 객체 수가 많아질수록 관리할 디렉토리 수가 늘어나거나 같은 파일에서 여러 개발자가 수정하며 충돌이 발생할 수 있다는 단점이 있다.  
**차트는 다양한 요구 조건을 처리할 수 있는 패키지다.**

> helm은 기존 쿠버네티스에서 사용하던 yaml 파일을 묶어 관리하는 패키지다.  
> 개발 파트: 앱 개발자가 코드를 작성 및 수정해 docker registry에 이미지로 올린다.  
> 패키징 파트: 코드 수정에 관계 없이 오로지 도커에 올라온 이미지만을 이용

helm은 yaml 파일에서 공통으로 사용되는 값을 vlaue.yaml 파일에서 변수와 같은 key로 묶어 관리하고 쿠버네티스의 yaml 파일을 직접 수정하지 않도록 한다.



남은 할일  
1. helm으로 배포해보기  

2. NodePort 대체해보기 -> 모든 노드에 Port를 차지하지 않도록 효율적으로 개선  
**로드 밸런서**  
service 자체에 퍼블릭 IP를 제공하는 방식, 퍼블릭 IP 풀이 있다면 갖다 쓰면 되니까 이지하지만 없다면 기반을 일일이 깔아줘야 함 쏘 디피컬트  
**인그레스**  
퍼블릭 Ip 쓸 필요없이 ingress로 각 API의 service를 라우팅 해주는 하나의 Pod(또는 디플로이먼트와 같이 실행 단위)를 생성해 각 클러스터의 port를 하나만 노출시키도록 하는 방식 
   * ingress에 요청 url 등의 정보를 각 API service와 매칭시키는 문서를 작성  
   * ingress 정보를 읽고 요청을 처리해줄 ingress manager(일종의 Deployment) 생성
   * ingress manager를 위한 service 생성  